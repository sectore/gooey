<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gooey WebGPU</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #1a1a2e;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: system-ui, sans-serif;
      }
      #container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        border-radius: 8px;
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
      }

      #status {
        color: #888;
        font-size: 14px;
      }
      .error {
        color: #e74c3c;
      }
      .success {
        color: #2ecc71;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="canvas" width="800" height="600"></canvas>
      <input
        id="hiddenInput"
        type="text"
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
        style="
          position: absolute;
          left: -9999px;
          top: 0;
          width: 1px;
          height: 1px;
          opacity: 0;
          pointer-events: none;
        "
      />
    </div>

    <script type="module">
      const canvas = document.getElementById("canvas");

      // Handle high-DPI displays
      const dpr = window.devicePixelRatio || 1;
      // Maximum texture size (WebGPU default limit)
      const MAX_SIZE = 8192;

      function updateCanvasSize() {
        // Use CSS size, not canvas.width (which we're about to set)
        const cssWidth = canvas.clientWidth;
        const cssHeight = canvas.clientHeight;

        // Calculate device pixel size, clamped to max texture size
        const targetWidth = Math.min(Math.floor(cssWidth * dpr), MAX_SIZE);
        const targetHeight = Math.min(Math.floor(cssHeight * dpr), MAX_SIZE);

        // Only update if actually changed
        if (canvas.width !== targetWidth || canvas.height !== targetHeight) {
          canvas.width = targetWidth;
          canvas.height = targetHeight;
          return true; // Size changed
        }
        return false; // No change
      }

      // Set initial size
      updateCanvasSize();

      // WebGPU state
      let device, queue, context, format;
      let wasmInstance;

      // Resource handle management (JS owns the actual GPU objects)
      const handles = {
        shaderModules: new Map(),
        pipelines: new Map(),
        buffers: new Map(),
        bindGroups: new Map(),
        textureViews: new Map(),
        textures: new Map(),
        samplers: new Map(),
        nextId: 1,
      };

      function allocHandle(map, obj) {
        const id = handles.nextId++;
        map.set(id, obj);
        return id;
      }

      // Text encoder for string conversion
      const textDecoder = new TextDecoder();

      function getString(ptr, len) {
        const memory = wasmInstance.exports.memory;
        return textDecoder.decode(new Uint8Array(memory.buffer, ptr, len));
      }

      // =========================================================
      // Mouse Input System (Shared Memory Ring Buffer)
      // =========================================================

      const MOUSE_RING_SIZE = 32;
      let mouseRingPtr = 0;

      // Current mouse state (for polling fallback and drag detection)
      let mouseX = 0,
        mouseY = 0,
        mouseButtons = 0,
        mouseInCanvas = false;

      // Multi-click detection state
      let lastClickTime = 0;
      let lastClickX = 0;
      let lastClickY = 0;
      let clickCount = 0;
      const DOUBLE_CLICK_TIME = 400; // ms
      const DOUBLE_CLICK_RADIUS = 5; // pixels

      // Current modifier state (tracked from keyboard events)
      let currentModifiers = 0;

      function initMouse() {
        mouseRingPtr = wasmInstance.exports.getMouseRingPtr();
        console.log("[Gooey] Mouse initialized, mouseRingPtr:", mouseRingPtr);

        // Mouse button events
        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mouseup", handleMouseUp);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseenter", handleMouseEnter);
        canvas.addEventListener("mouseleave", handleMouseLeave);

        // Prevent context menu on right-click
        canvas.addEventListener("contextmenu", (e) => e.preventDefault());

        // Track modifiers from keyboard
        window.addEventListener("keydown", updateModifiers);
        window.addEventListener("keyup", updateModifiers);
      }

      function updateModifiers(e) {
        currentModifiers =
          (e.shiftKey ? 1 : 0) |
          (e.ctrlKey ? 2 : 0) |
          (e.altKey ? 4 : 0) |
          (e.metaKey ? 8 : 0);
      }

      function getModifiersFromEvent(e) {
        return (
          (e.shiftKey ? 1 : 0) |
          (e.ctrlKey ? 2 : 0) |
          (e.altKey ? 4 : 0) |
          (e.metaKey ? 8 : 0)
        );
      }

      function getClickCount(x, y, now) {
        const timeDelta = now - lastClickTime;
        const distSq =
          (x - lastClickX) * (x - lastClickX) +
          (y - lastClickY) * (y - lastClickY);

        if (
          timeDelta < DOUBLE_CLICK_TIME &&
          distSq < DOUBLE_CLICK_RADIUS * DOUBLE_CLICK_RADIUS
        ) {
          clickCount = Math.min(clickCount + 1, 3); // Cap at triple-click
        } else {
          clickCount = 1;
        }

        lastClickTime = now;
        lastClickX = x;
        lastClickY = y;

        return clickCount;
      }

      function handleMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        mouseButtons |= 1 << e.button;
        mouseX = x;
        mouseY = y;

        const count = getClickCount(x, y, performance.now());
        const modifiers = getModifiersFromEvent(e);
        currentModifiers = modifiers;

        pushMouseEvent(0, e.button, x, y, count, modifiers); // 0 = mouse_down
      }

      function handleMouseUp(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        mouseButtons &= ~(1 << e.button);
        mouseX = x;
        mouseY = y;

        const modifiers = getModifiersFromEvent(e);
        currentModifiers = modifiers;

        pushMouseEvent(1, e.button, x, y, clickCount, modifiers); // 1 = mouse_up
      }

      function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        mouseX = x;
        mouseY = y;

        const modifiers = getModifiersFromEvent(e);
        currentModifiers = modifiers;

        // Determine if this is a drag (any button pressed) or just a move
        const eventType = mouseButtons !== 0 ? 3 : 2; // 3 = mouse_dragged, 2 = mouse_moved

        // For drags, use the primary button that's pressed
        const button =
          mouseButtons & 1
            ? 0
            : mouseButtons & 2
              ? 1
              : mouseButtons & 4
                ? 2
                : 0;

        pushMouseEvent(eventType, button, x, y, 0, modifiers);
      }

      function handleMouseEnter(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        mouseInCanvas = true;
        const modifiers = getModifiersFromEvent(e);

        pushMouseEvent(4, 0, x, y, 0, modifiers); // 4 = mouse_entered
      }

      function handleMouseLeave(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        mouseInCanvas = false;
        mouseButtons = 0; // Clear buttons on leave

        const modifiers = getModifiersFromEvent(e);

        pushMouseEvent(5, 0, x, y, 0, modifiers); // 5 = mouse_exited
      }

      function pushMouseEvent(
        eventType,
        button,
        posX,
        posY,
        clickCount,
        modifiers,
      ) {
        if (!mouseRingPtr) return;

        const mem = wasmInstance.exports.memory.buffer;
        const header = new Uint32Array(mem, mouseRingPtr, 2);

        const writeHead = header[0];
        const readHead = header[1];

        // Check if ring is full
        if (
          ((writeHead + 1) & (MOUSE_RING_SIZE - 1)) ===
          (readHead & (MOUSE_RING_SIZE - 1))
        ) {
          console.warn("[Gooey] Mouse event buffer full, dropping event");
          return;
        }

        // Calculate slot address: 8-byte header + slot * 24 bytes per event
        const slot = writeHead & (MOUSE_RING_SIZE - 1);
        const eventOffset = mouseRingPtr + 8 + slot * 24;

        const view = new DataView(mem, eventOffset, 24);
        view.setFloat64(0, posX, true); // position_x
        view.setFloat64(8, posY, true); // position_y
        view.setUint8(16, eventType); // event_type
        view.setUint8(17, button); // button (0=left, 1=right, 2=middle)
        view.setUint8(18, clickCount); // click_count
        view.setUint8(19, modifiers); // modifiers
        view.setUint32(20, 0, true); // reserved

        // Advance write head
        header[0] = writeHead + 1;
      }

      // =========================================================
      // Scroll/Wheel Input System (Shared Memory Ring Buffer)
      // =========================================================

      const SCROLL_RING_SIZE = 16;
      let scrollRingPtr = 0;

      function initScroll() {
        scrollRingPtr = wasmInstance.exports.getScrollRingPtr();
        console.log(
          "[Gooey] Scroll initialized, scrollRingPtr:",
          scrollRingPtr,
        );

        canvas.addEventListener("wheel", handleWheel, { passive: false });
      }

      function handleWheel(e) {
        e.preventDefault(); // Prevent page scrolling

        if (!scrollRingPtr) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // deltaMode: 0 = pixels, 1 = lines, 2 = pages
        let deltaX = e.deltaX;
        let deltaY = e.deltaY;

        // Normalize line/page deltas to pixels
        if (e.deltaMode === 1) {
          deltaX *= 20; // ~1 line = 20px
          deltaY *= 20;
        } else if (e.deltaMode === 2) {
          deltaX *= canvas.clientHeight;
          deltaY *= canvas.clientHeight;
        }

        pushScrollEvent(x, y, deltaX, deltaY);
      }

      function pushScrollEvent(posX, posY, deltaX, deltaY) {
        const mem = wasmInstance.exports.memory.buffer;
        const header = new Uint32Array(mem, scrollRingPtr, 2);

        const writeHead = header[0];
        const readHead = header[1];

        // Check if ring is full
        if (
          ((writeHead + 1) & (SCROLL_RING_SIZE - 1)) ===
          (readHead & (SCROLL_RING_SIZE - 1))
        ) {
          console.warn("[Gooey] Scroll event buffer full, dropping event");
          return;
        }

        // Calculate slot address: 8-byte header + slot * 24 bytes per event
        const slot = writeHead & (SCROLL_RING_SIZE - 1);
        const eventOffset = scrollRingPtr + 8 + slot * 24;

        const view = new DataView(mem, eventOffset, 24);
        view.setFloat64(0, posX, true); // position_x
        view.setFloat64(8, posY, true); // position_y
        view.setFloat32(16, deltaX, true); // delta_x
        view.setFloat32(20, deltaY, true); // delta_y

        // Advance write head
        header[0] = writeHead + 1;
      }

      // =========================================================
      // Keyboard Input System (Shared Memory Ring Buffers)
      // =========================================================

      // Map browser key codes to macOS virtual key codes
      // Used by Gooey's KeyCode enum
      const KEY_CODE_MAP = {
        // Letters (QWERTY layout, macOS keycodes)
        KeyA: 0x00,
        KeyS: 0x01,
        KeyD: 0x02,
        KeyF: 0x03,
        KeyH: 0x04,
        KeyG: 0x05,
        KeyZ: 0x06,
        KeyX: 0x07,
        KeyC: 0x08,
        KeyV: 0x09,
        KeyB: 0x0b,
        KeyQ: 0x0c,
        KeyW: 0x0d,
        KeyE: 0x0e,
        KeyR: 0x0f,
        KeyY: 0x10,
        KeyT: 0x11,
        KeyO: 0x1f,
        KeyU: 0x20,
        KeyI: 0x22,
        KeyP: 0x23,
        KeyL: 0x25,
        KeyJ: 0x26,
        KeyK: 0x28,
        KeyN: 0x2d,
        KeyM: 0x2e,

        // Numbers
        Digit1: 0x12,
        Digit2: 0x13,
        Digit3: 0x14,
        Digit4: 0x15,
        Digit5: 0x17,
        Digit6: 0x16,
        Digit7: 0x1a,
        Digit8: 0x1c,
        Digit9: 0x19,
        Digit0: 0x1d,

        // Special keys
        Enter: 0x24,
        Tab: 0x30,
        Space: 0x31,
        Backspace: 0x33,
        Escape: 0x35,
        Delete: 0x75, // Forward delete

        // Modifiers (for flagsChanged-style events)
        MetaLeft: 0x37,
        MetaRight: 0x36,
        ShiftLeft: 0x38,
        ShiftRight: 0x3c,
        CapsLock: 0x39,
        AltLeft: 0x3a,
        AltRight: 0x3d,
        ControlLeft: 0x3b,
        ControlRight: 0x3e,

        // Arrow keys
        ArrowLeft: 0x7b,
        ArrowRight: 0x7c,
        ArrowDown: 0x7d,
        ArrowUp: 0x7e,

        // Navigation
        Home: 0x73,
        End: 0x77,
        PageUp: 0x74,
        PageDown: 0x79,

        // Function keys
        F1: 0x7a,
        F2: 0x78,
        F3: 0x63,
        F4: 0x76,
        F5: 0x60,
        F6: 0x61,
        F7: 0x62,
        F8: 0x64,
        F9: 0x65,
        F10: 0x6d,
        F11: 0x67,
        F12: 0x6f,
      };

      const UNKNOWN_KEY = 0xffff;
      const RING_SIZE = 32;
      const TEXT_BUFFER_SIZE = 256;

      let keyRingPtr = 0;
      let textBufferPtr = 0;

      function initKeyboard() {
        // Get buffer pointers from WASM
        keyRingPtr = wasmInstance.exports.getKeyRingPtr();
        textBufferPtr = wasmInstance.exports.getTextBufferPtr();

        const hiddenInput = document.getElementById("hiddenInput");

        // Make canvas focusable for key events
        canvas.tabIndex = 0;
        canvas.style.outline = "none";

        // Key events on canvas (physical keys for navigation/shortcuts)
        canvas.addEventListener("keydown", (e) => {
          // Forward focus to hidden input for text entry
          if (!e.metaKey && !e.ctrlKey && !e.altKey && e.key.length === 1) {
            hiddenInput.focus();
          }
          handleKeyDown(e);
        });
        canvas.addEventListener("keyup", handleKeyUp);

        // Text input via hidden input element
        hiddenInput.addEventListener("input", (e) => {
          if (hiddenInput.value) {
            appendText(hiddenInput.value);
            hiddenInput.value = ""; // Clear after capturing
          }
        });

        // Handle composition (IME) on hidden input
        hiddenInput.addEventListener("compositionend", (e) => {
          if (e.data) {
            appendText(e.data);
            hiddenInput.value = "";
          }
        });

        // Forward key events from hidden input to canvas logic
        hiddenInput.addEventListener("keydown", (e) => {
          handleKeyDown(e);
          // Return focus to canvas for non-printable keys
          if (shouldPreventDefault(e)) {
            e.preventDefault();
            canvas.focus();
          }
        });
        hiddenInput.addEventListener("keyup", handleKeyUp);

        // Keep hidden input in sync when canvas is focused
        canvas.addEventListener("focus", () => {
          // Small delay to let click processing complete
          setTimeout(() => {
            if (document.activeElement === canvas) {
              hiddenInput.focus();
            }
          }, 10);
        });

        // Click on canvas focuses the hidden input
        canvas.addEventListener("click", () => {
          hiddenInput.focus();
        });

        // Initial focus
        hiddenInput.focus();

        console.log(
          "[Gooey] Keyboard initialized, keyRingPtr:",
          keyRingPtr,
          "textBufferPtr:",
          textBufferPtr,
        );
      }

      function handleKeyDown(e) {
        // Prevent browser defaults for keys we handle
        if (shouldPreventDefault(e)) {
          e.preventDefault();
        }
        pushKeyEvent(0, e); // 0 = key_down
        console.log("[Gooey] keydown:", e.code, e.key); // Debug
      }

      function handleKeyUp(e) {
        pushKeyEvent(1, e); // 1 = key_up
      }

      function handleBeforeInput(e) {
        // Captures: typing, paste, emoji picker, autocorrect
        if (e.data) {
          e.preventDefault();
          appendText(e.data);
        }
      }

      function handleCompositionEnd(e) {
        // Captures: IME completion (CJK, etc.)
        if (e.data) {
          appendText(e.data);
        }
      }

      function shouldPreventDefault(e) {
        // Prevent defaults for navigation and common shortcuts
        const dominated = [
          "Tab",
          "Enter",
          "Backspace",
          "Delete",
          "Escape",
          "ArrowLeft",
          "ArrowRight",
          "ArrowUp",
          "ArrowDown",
          "Home",
          "End",
          "PageUp",
          "PageDown",
        ];

        if (dominated.includes(e.code)) return true;
        if (e.metaKey || e.ctrlKey) return true; // Shortcuts

        return false;
      }

      function pushKeyEvent(eventType, e) {
        if (!keyRingPtr) return;

        const mem = wasmInstance.exports.memory.buffer;
        const header = new Uint32Array(mem, keyRingPtr, 2);

        const writeHead = header[0];
        const readHead = header[1];

        // Check if ring is full
        if (
          ((writeHead + 1) & (RING_SIZE - 1)) ===
          (readHead & (RING_SIZE - 1))
        ) {
          console.warn("[Gooey] Key event buffer full, dropping event");
          return;
        }

        // Calculate slot address
        const slot = writeHead & (RING_SIZE - 1);
        const eventOffset = keyRingPtr + 8 + slot * 8; // 8-byte header

        const bytes = new Uint8Array(mem, eventOffset, 8);
        const view = new DataView(mem, eventOffset, 8);

        // Write event (8 bytes)
        bytes[0] = eventType; // event_type
        view.setUint16(1, KEY_CODE_MAP[e.code] ?? UNKNOWN_KEY, true); // key_code (little-endian)
        bytes[3] = packModifiers(e); // modifiers
        bytes[4] = (e.repeat ? 1 : 0) | (e.isComposing ? 2 : 0); // flags
        bytes[5] = 0; // reserved
        bytes[6] = 0; // reserved
        bytes[7] = 0; // reserved

        // Advance write head
        header[0] = writeHead + 1;
      }

      function packModifiers(e) {
        return (
          (e.shiftKey ? 1 : 0) |
          (e.ctrlKey ? 2 : 0) |
          (e.altKey ? 4 : 0) |
          (e.metaKey ? 8 : 0)
        );
      }

      function appendText(text) {
        if (!textBufferPtr) return;

        const mem = wasmInstance.exports.memory.buffer;
        const lenPtr = new Uint32Array(mem, textBufferPtr, 1);
        const dataPtr = new Uint8Array(
          mem,
          textBufferPtr + 4,
          TEXT_BUFFER_SIZE,
        );

        const encoded = new TextEncoder().encode(text);
        const currentLen = lenPtr[0];
        const available = TEXT_BUFFER_SIZE - currentLen;

        if (encoded.length > available) {
          console.warn("[Gooey] Text buffer full, truncating input");
        }

        const writeLen = Math.min(encoded.length, available);
        dataPtr.set(encoded.subarray(0, writeLen), currentLen);
        lenPtr[0] = currentLen + writeLen;
      }

      // Text rendering helper
      const textCanvas = new OffscreenCanvas(256, 256);
      const textCtx = textCanvas.getContext("2d", { willReadFrequently: true });

      function getFont(fontPtr, fontLen, size) {
        const fontName = getString(fontPtr, fontLen);
        return `${size}px ${fontName}`;
      }

      // Environment functions provided to WASM
      const env = {
        consoleLog: (ptr, len) => console.log("[WASM]", getString(ptr, len)),
        consoleError: (ptr, len) =>
          console.error("[WASM]", getString(ptr, len)),

        getTimestampMillis: () => Date.now(),

        getCanvasWidth: () => canvas.clientWidth,
        getCanvasHeight: () => canvas.clientHeight,
        getDevicePixelRatio: () => dpr,
        setCanvasSize: (w, h) => {
          canvas.width = w;
          canvas.height = h;
        },

        getCurrentTextureView: () => {
          const texture = context.getCurrentTexture();
          const view = texture.createView();
          return allocHandle(handles.textureViews, view);
        },

        releaseTextureView: (handle) => {
          handles.textureViews.delete(handle);
        },

        createShaderModule: (codePtr, codeLen) => {
          const code = getString(codePtr, codeLen);
          const module = device.createShaderModule({ code });
          return allocHandle(handles.shaderModules, module);
        },

        createRenderPipeline: (shaderHandle, vsPtr, vsLen, fsPtr, fsLen) => {
          const module = handles.shaderModules.get(shaderHandle);
          const vsEntry = getString(vsPtr, vsLen);
          const fsEntry = getString(fsPtr, fsLen);

          const pipeline = device.createRenderPipeline({
            layout: "auto",
            vertex: {
              module,
              entryPoint: vsEntry,
            },
            fragment: {
              module,
              entryPoint: fsEntry,
              targets: [
                {
                  format,
                  blend: {
                    color: {
                      srcFactor: "src-alpha",
                      dstFactor: "one-minus-src-alpha",
                      operation: "add",
                    },
                    alpha: {
                      srcFactor: "one",
                      dstFactor: "one-minus-src-alpha",
                      operation: "add",
                    },
                  },
                },
              ],
            },
            primitive: {
              topology: "triangle-list",
            },
          });
          return allocHandle(handles.pipelines, pipeline);
        },

        createBuffer: (size, usage) => {
          const buffer = device.createBuffer({ size, usage });
          return allocHandle(handles.buffers, buffer);
        },

        writeBuffer: (handle, offset, dataPtr, dataLen) => {
          const buffer = handles.buffers.get(handle);
          const memory = wasmInstance.exports.memory;
          const data = new Uint8Array(memory.buffer, dataPtr, dataLen);
          queue.writeBuffer(buffer, offset, data);
        },

        createBindGroup: (
          pipelineHandle,
          groupIndex,
          bufferHandlesPtr,
          bufferHandlesLen,
        ) => {
          const pipeline = handles.pipelines.get(pipelineHandle);
          const memory = wasmInstance.exports.memory;
          const handleArray = new Uint32Array(
            memory.buffer,
            bufferHandlesPtr,
            bufferHandlesLen,
          );

          const entries = [];
          for (let i = 0; i < bufferHandlesLen; i++) {
            const buffer = handles.buffers.get(handleArray[i]);
            entries.push({
              binding: i,
              resource: { buffer },
            });
          }

          const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(groupIndex),
            entries,
          });
          return allocHandle(handles.bindGroups, bindGroup);
        },

        // Render pass state
        currentEncoder: null,
        currentPass: null,

        beginRenderPass: (textureViewHandle, r, g, b, a) => {
          const view = handles.textureViews.get(textureViewHandle);
          env.currentEncoder = device.createCommandEncoder();
          env.currentPass = env.currentEncoder.beginRenderPass({
            colorAttachments: [
              {
                view,
                clearValue: { r, g, b, a },
                loadOp: "clear",
                storeOp: "store",
              },
            ],
          });
        },

        setPipeline: (pipelineHandle) => {
          const pipeline = handles.pipelines.get(pipelineHandle);
          env.currentPass.setPipeline(pipeline);
        },

        setBindGroup: (groupIndex, bindGroupHandle) => {
          const bindGroup = handles.bindGroups.get(bindGroupHandle);
          env.currentPass.setBindGroup(groupIndex, bindGroup);
        },

        drawInstanced: (vertexCount, instanceCount) => {
          env.currentPass.draw(vertexCount, instanceCount);
        },

        endRenderPass: () => {
          env.currentPass.end();
          queue.submit([env.currentEncoder.finish()]);
          env.currentPass = null;
          env.currentEncoder = null;
        },

        requestAnimationFrame: () => {
          requestAnimationFrame((timestamp) => {
            wasmInstance.exports.frame(timestamp);
          });
        },

        getFrameTime: () => performance.now(),

        getMouseX: () => mouseX,
        getMouseY: () => mouseY,
        getMouseButtons: () => mouseButtons,
        isMouseInCanvas: () => mouseInCanvas,

        getFontMetrics: (
          fontPtr,
          fontLen,
          size,
          outAscent,
          outDescent,
          outLineHeight,
        ) => {
          const font = getFont(fontPtr, fontLen, size);
          textCtx.font = font;
          const metrics = textCtx.measureText("Hg");
          const ascent = metrics.actualBoundingBoxAscent;
          const descent = metrics.actualBoundingBoxDescent;
          const lineHeight = ascent + descent + 4; // Add some padding

          const mem = new DataView(wasmInstance.exports.memory.buffer);
          mem.setFloat32(outAscent, ascent, true);
          mem.setFloat32(outDescent, descent, true);
          mem.setFloat32(outLineHeight, lineHeight, true);
        },

        measureText: (fontPtr, fontLen, size, textPtr, textLen) => {
          const font = getFont(fontPtr, fontLen, size);
          const text = getString(textPtr, textLen);
          textCtx.font = font;
          return textCtx.measureText(text).width;
        },

        rasterizeGlyph: (
          fontPtr,
          fontLen,
          size,
          codepoint,
          outBuffer,
          bufferSize,
          outWidth,
          outHeight,
          outBearingX,
          outBearingY,
          outAdvance,
        ) => {
          const font = getFont(fontPtr, fontLen, size);
          const char = String.fromCodePoint(codepoint);

          textCtx.font = font;
          textCtx.textBaseline = "alphabetic";
          const metrics = textCtx.measureText(char);

          // These are distances from the origin point (where we draw)
          const left = Math.ceil(metrics.actualBoundingBoxLeft); // extends LEFT of origin
          const right = Math.ceil(metrics.actualBoundingBoxRight); // extends RIGHT of origin
          const ascent = Math.ceil(metrics.actualBoundingBoxAscent); // extends ABOVE baseline
          const descent = Math.ceil(metrics.actualBoundingBoxDescent); // extends BELOW baseline

          const padding = 2;
          const width = left + right + padding;
          const height = ascent + descent + padding;
          const advance = metrics.width;

          // Resize canvas if needed
          if (textCanvas.width < width) textCanvas.width = Math.max(256, width);
          if (textCanvas.height < height)
            textCanvas.height = Math.max(256, height);

          // Clear and draw - position so glyph is fully visible
          // Draw at x=left+1 so left edge is at x=1
          // Draw at y=ascent+1 so top edge is at y=1
          textCtx.clearRect(0, 0, width, height);
          textCtx.font = font;
          textCtx.fillStyle = "white";
          textCtx.textBaseline = "alphabetic";
          textCtx.fillText(char, left + 1, ascent + 1);

          // Extract alpha channel
          const imageData = textCtx.getImageData(0, 0, width, height);
          const mem = new Uint8Array(
            wasmInstance.exports.memory.buffer,
            outBuffer,
            bufferSize,
          );
          for (let i = 0; i < width * height && i < bufferSize; i++) {
            mem[i] = imageData.data[i * 4 + 3];
          }

          // Output values:
          // - bearingX: how far RIGHT of cursor the glyph bitmap starts (negative = starts left of cursor)
          // - bearingY: how far DOWN from cursor the glyph bitmap starts (negative = starts above cursor)
          // For alphabetic baseline: bitmap top is at cursor_y - ascent
          const view = new DataView(wasmInstance.exports.memory.buffer);
          view.setUint32(outWidth, width, true);
          view.setUint32(outHeight, height, true);
          view.setFloat32(outBearingX, -(left + 1), true); // Offset from cursor to bitmap left edge
          view.setFloat32(outBearingY, -(ascent - 1), true); // Offset from baseline to bitmap top edge
          view.setFloat32(outAdvance, advance, true);

          // console.log(
          //   `Rasterized '${char}': ${width}x${height}, bearing=(${-(left + 1)}, ${-(ascent + 1)}), advance=${advance}`,
          // );
        },

        createTexture: (width, height, dataPtr, dataLen) => {
          const data = new Uint8Array(
            wasmInstance.exports.memory.buffer,
            dataPtr,
            dataLen,
          );
          const texture = device.createTexture({
            size: { width, height },
            format: "r8unorm",
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
          });
          queue.writeTexture(
            { texture },
            data,
            { bytesPerRow: width },
            { width, height },
          );
          return allocHandle(handles.textures, texture);
        },

        updateTexture: (textureHandle, width, height, dataPtr, dataLen) => {
          const texture = handles.textures.get(textureHandle);
          if (!texture) {
            console.error(
              "updateTexture: invalid texture handle",
              textureHandle,
            );
            return;
          }
          const data = new Uint8Array(
            wasmInstance.exports.memory.buffer,
            dataPtr,
            dataLen,
          );
          queue.writeTexture(
            { texture },
            data,
            { bytesPerRow: width },
            { width, height },
          );
        },

        createSampler: () => {
          const sampler = device.createSampler({
            magFilter: "linear",
            minFilter: "linear",
          });
          return allocHandle(handles.samplers, sampler);
        },

        createTextBindGroup: (
          pipelineHandle,
          groupIndex,
          glyphBuffer,
          uniformBuffer,
          textureHandle,
          samplerHandle,
        ) => {
          const pipeline = handles.pipelines.get(pipelineHandle);
          const texture = handles.textures.get(textureHandle);
          const sampler = handles.samplers.get(samplerHandle);

          const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(groupIndex),
            entries: [
              {
                binding: 0,
                resource: { buffer: handles.buffers.get(glyphBuffer) },
              },
              {
                binding: 1,
                resource: { buffer: handles.buffers.get(uniformBuffer) },
              },
              { binding: 2, resource: texture.createView() },
              { binding: 3, resource: sampler },
            ],
          });
          return allocHandle(handles.bindGroups, bindGroup);
        },

        // =====================================================================
        // Post-Processing Support
        // =====================================================================

        // Create a render texture (can be rendered to and sampled from)
        createRenderTexture: (width, height) => {
          const texture = device.createTexture({
            size: { width, height },
            format: format, // Use the same format as the canvas
            usage:
              GPUTextureUsage.TEXTURE_BINDING |
              GPUTextureUsage.RENDER_ATTACHMENT |
              GPUTextureUsage.COPY_SRC |
              GPUTextureUsage.COPY_DST,
          });
          return allocHandle(handles.textures, texture);
        },

        // Create a texture view from a texture handle
        createTextureView: (textureHandle) => {
          const texture = handles.textures.get(textureHandle);
          if (!texture) {
            console.error(
              "createTextureView: invalid texture handle",
              textureHandle,
            );
            return 0;
          }
          const view = texture.createView();
          return allocHandle(handles.textureViews, view);
        },

        // Create a post-process render pipeline (fullscreen shader)
        createPostProcessPipeline: (shaderHandle) => {
          const module = handles.shaderModules.get(shaderHandle);
          if (!module) {
            console.error(
              "createPostProcessPipeline: invalid shader handle",
              shaderHandle,
            );
            return 0;
          }

          const pipeline = device.createRenderPipeline({
            layout: "auto",
            vertex: {
              module,
              entryPoint: "vs_main",
            },
            fragment: {
              module,
              entryPoint: "fs_main",
              targets: [
                {
                  format: format,
                  blend: {
                    color: {
                      srcFactor: "src-alpha",
                      dstFactor: "one-minus-src-alpha",
                      operation: "add",
                    },
                    alpha: {
                      srcFactor: "one",
                      dstFactor: "one-minus-src-alpha",
                      operation: "add",
                    },
                  },
                },
              ],
            },
            primitive: {
              topology: "triangle-list",
            },
          });
          return allocHandle(handles.pipelines, pipeline);
        },

        // Create a bind group for post-process shader
        createPostProcessBindGroup: (
          pipelineHandle,
          uniformBuffer,
          textureHandle,
          samplerHandle,
        ) => {
          const pipeline = handles.pipelines.get(pipelineHandle);
          const texture = handles.textures.get(textureHandle);
          const sampler = handles.samplers.get(samplerHandle);

          if (!pipeline || !texture || !sampler) {
            console.error("createPostProcessBindGroup: invalid handles", {
              pipeline: !!pipeline,
              texture: !!texture,
              sampler: !!sampler,
            });
            return 0;
          }

          const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
              {
                binding: 0,
                resource: { buffer: handles.buffers.get(uniformBuffer) },
              },
              {
                binding: 1,
                resource: texture.createView(),
              },
              {
                binding: 2,
                resource: sampler,
              },
            ],
          });
          return allocHandle(handles.bindGroups, bindGroup);
        },

        // Begin a render pass to a texture (not the screen)
        beginTextureRenderPass: (textureViewHandle, r, g, b, a) => {
          const view = handles.textureViews.get(textureViewHandle);
          if (!view) {
            console.error(
              "beginTextureRenderPass: invalid texture view handle",
              textureViewHandle,
            );
            return;
          }
          env.currentEncoder = device.createCommandEncoder();
          env.currentPass = env.currentEncoder.beginRenderPass({
            colorAttachments: [
              {
                view,
                clearValue: { r, g, b, a },
                loadOp: "clear",
                storeOp: "store",
              },
            ],
          });
        },

        // Copy the current screen to a texture for post-processing
        copyToTexture: (srcViewHandle, dstTextureHandle, width, height) => {
          const srcView = handles.textureViews.get(srcViewHandle);
          const dstTexture = handles.textures.get(dstTextureHandle);
          if (!srcView || !dstTexture) {
            console.error("copyToTexture: invalid handles");
            return;
          }
          // Note: This would need a blit operation or render pass
          // For now, we use render-to-texture approach instead
        },
      };

      async function init() {
        // Check WebGPU support
        if (!navigator.gpu) {
          console.error("WebGPU not supported in this browser");
          return;
        }

        // Request adapter and device
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          console.error("Failed to get WebGPU adapter");
          return;
        }

        device = await adapter.requestDevice();
        queue = device.queue;

        // Configure canvas context
        context = canvas.getContext("webgpu");
        format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format, alphaMode: "premultiplied" });

        // Load WASM
        const response = await fetch("app.wasm");
        const wasmBytes = await response.arrayBuffer();
        const { instance } = await WebAssembly.instantiate(wasmBytes, { env });
        wasmInstance = instance;

        // Handle resize - debounced to avoid loops
        let resizeTimeout = null;
        const resizeObserver = new ResizeObserver(() => {
          if (resizeTimeout) return; // Already scheduled
          resizeTimeout = setTimeout(() => {
            resizeTimeout = null;
            if (updateCanvasSize() && context) {
              context.configure({ device, format, alphaMode: "premultiplied" });
            }
          }, 16); // ~1 frame debounce
        });
        resizeObserver.observe(canvas);

        // Initialize and start
        wasmInstance.exports.init();

        // Initialize after WASM is ready
        initKeyboard();
        initScroll();
        initMouse();
      }

      init().catch((err) => {
        console.error(err);
      });
    </script>
  </body>
</html>
