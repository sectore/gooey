diff --git a/src/app.zig b/src/app.zig
index 2b4f13f..d001f3b 100644
--- a/src/app.zig
+++ b/src/app.zig
@@ -288,6 +288,12 @@ pub fn CxConfig(comptime State: type) type {
 
         /// Corner radius for glass effect (macOS 26+ only)
         glass_corner_radius: f64 = 16.0,
+
+        /// Make titlebar transparent (blends with window content)
+        titlebar_transparent: bool = false,
+
+        /// Extend content under titlebar (full bleed)
+        full_size_content: bool = false,
     };
 }
 
@@ -347,6 +353,8 @@ pub fn runCx(
         .background_opacity = config.background_opacity,
         .glass_style = config.glass_style,
         .glass_corner_radius = config.glass_corner_radius,
+        .titlebar_transparent = config.titlebar_transparent,
+        .full_size_content = config.full_size_content,
     });
     defer window.deinit();
 
diff --git a/src/examples/glass.zig b/src/examples/glass.zig
index d9ba2ad..e44e780 100644
--- a/src/examples/glass.zig
+++ b/src/examples/glass.zig
@@ -75,12 +75,15 @@ pub fn main() !void {
         .title = "Liquid Glass Demo",
         .width = 500,
         .height = 400,
-        .background_color = gooey.Color.init(0.1, 0.1, 0.15, 0.6),
-        // Enable transparency - required for glass effects
+        // .background_color = gooey.Color.init(0.1, 0.1, 0.15, 0.6),
+        // // Enable transparency - required for glass effects
         .background_opacity = 0.3,
         // Request liquid glass (falls back to blur on older macOS)
         .glass_style = .glass_clear,
         .glass_corner_radius = 20.0,
+        // Transparent titlebar options
+        .titlebar_transparent = true,
+        .full_size_content = true, // Content extends under titlebar
     });
 }
 
diff --git a/src/platform/mac/window.zig b/src/platform/mac/window.zig
index 0f0f77a..86ced57 100644
--- a/src/platform/mac/window.zig
+++ b/src/platform/mac/window.zig
@@ -94,6 +94,16 @@ pub const Window = struct {
     // Convenience accessors (so user code doesn't need to convert)
     // =========================================================================
 
+    /// Get the effective clear color for rendering.
+    /// When glass effects are active, returns transparent so the glass shows through.
+    /// Otherwise returns the configured background color.
+    pub fn getClearColor(self: *const Self) geometry.Color {
+        return switch (self.glass_style) {
+            .glass_regular, .glass_clear => geometry.Color.transparent,
+            .blur, .none => self.background_color,
+        };
+    }
+
     /// Window width in logical pixels
     pub fn width(self: *const Self) u32 {
         return @intFromFloat(self.size.width);
@@ -130,7 +140,7 @@ pub const Window = struct {
         title: []const u8 = "gooey Window",
         width: f64 = 800,
         height: f64 = 600,
-        background_color: geometry.Color = geometry.Color.init(0.2, 0.2, 0.25, 1.0),
+        background_color: geometry.Color = geometry.Color.transparent,
         use_display_link: bool = true,
         custom_shaders: []const []const u8 = &.{},
         /// Background opacity (0.0 = fully transparent, 1.0 = opaque)
@@ -140,6 +150,10 @@ pub const Window = struct {
         glass_style: GlassStyle = .none,
         /// Corner radius for glass effect (macOS 26+ only)
         glass_corner_radius: f64 = 16.0,
+        /// Make titlebar transparent (blends with window content)
+        titlebar_transparent: bool = false,
+        /// Extend content under titlebar (full bleed)
+        full_size_content: bool = false,
     };
 
     const Self = @This();
@@ -193,6 +207,19 @@ pub const Window = struct {
             },
         );
 
+        // Configure titlebar transparency
+        if (options.titlebar_transparent) {
+            self.ns_window.msgSend(void, "setTitlebarAppearsTransparent:", .{true});
+        }
+
+        // Extend content under titlebar for full-bleed effect
+        if (options.full_size_content) {
+            // Add NSWindowStyleMaskFullSizeContentView to existing style mask
+            const current_mask = self.ns_window.msgSend(u64, "styleMask", .{});
+            const full_size_content_mask: u64 = 1 << 15; // NSWindowStyleMaskFullSizeContentView
+            self.ns_window.msgSend(void, "setStyleMask:", .{current_mask | full_size_content_mask});
+        }
+
         const window_delegate = @import("window_delegate.zig");
         self.delegate = try window_delegate.create(self);
         self.ns_window.msgSend(void, "setDelegate:", .{self.delegate.?.value});
@@ -476,9 +503,9 @@ pub const Window = struct {
             }
 
             if (self.scene) |s| {
-                self.renderer.renderSceneSynchronous(s, self.background_color) catch {};
+                self.renderer.renderSceneSynchronous(s, self.getClearColor()) catch {};
             } else {
-                self.renderer.clearSynchronous(self.background_color);
+                self.renderer.clearSynchronous(self.getClearColor());
             }
         }
     }
@@ -520,7 +547,7 @@ pub const Window = struct {
 
     /// Manual render (for when display link is disabled)
     pub fn render(self: *Self) void {
-        self.renderer.clear(self.background_color);
+        self.renderer.clear(self.getClearColor());
     }
 
     pub fn setTitle(self: *Self, new_title: []const u8) void {
@@ -591,20 +618,20 @@ pub const Window = struct {
     }
 
     fn setupGlassEffect(self: *Self, style: GlassStyle, opacity: f64, corner_radius: f64) !void {
-        if (style == .none and opacity >= 1.0) return;
+        _ = opacity; // Opacity is handled by the glass tint, not window background
+        if (style == .none) return;
 
         // Make the window non-opaque for transparency
         self.ns_window.msgSend(void, "setOpaque:", .{false});
 
-        // Set background color with transparency
-        // Using a very low alpha (0.001) like Ghostty/Terminal.app for best results
+        // Set window background to nearly transparent
+        // The glass effect provides the actual visual background
         const NSColor = objc.getClass("NSColor") orelse return error.ClassNotFound;
-        const alpha = @max(0.001, @min(opacity, 1.0));
         const transparent_bg = NSColor.msgSend(objc.Object, "colorWithRed:green:blue:alpha:", .{
-            @as(f64, 1.0), // white base
             @as(f64, 1.0),
             @as(f64, 1.0),
-            alpha,
+            @as(f64, 1.0),
+            @as(f64, 0.001), // Nearly invisible - glass shows through
         });
         self.ns_window.msgSend(void, "setBackgroundColor:", .{transparent_bg.value});
 
@@ -875,22 +902,23 @@ fn displayLinkCallback(
 
     // Use post-process rendering if shaders are active
     if (window.scene) |s| {
+        const clear_color = window.getClearColor();
         if (window.renderer.hasCustomShaders()) {
-            window.renderer.renderSceneWithPostProcess(s, window.background_color) catch |err| {
+            window.renderer.renderSceneWithPostProcess(s, clear_color) catch |err| {
                 std.debug.print("renderSceneWithPostProcess error: {}\n", .{err});
                 // Fall back to normal render
-                window.renderer.renderScene(s, window.background_color) catch {
-                    window.renderer.clear(window.background_color);
+                window.renderer.renderScene(s, clear_color) catch {
+                    window.renderer.clear(clear_color);
                 };
             };
         } else {
-            window.renderer.renderScene(s, window.background_color) catch |err| {
+            window.renderer.renderScene(s, clear_color) catch |err| {
                 std.debug.print("renderScene error: {}\n", .{err});
-                window.renderer.clear(window.background_color);
+                window.renderer.clear(clear_color);
             };
         }
     } else {
-        window.renderer.clear(window.background_color);
+        window.renderer.clear(window.getClearColor());
     }
 
     return .success;
